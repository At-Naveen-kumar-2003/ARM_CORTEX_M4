1. PA0 is configured as an analog input for ADC1 channel 0, and PA5 is configured as a digital output to drive the LED.

2. ADC1 is enabled and set to read from channel 0, with sample time configured in SMPR2 and conversion started using software trigger (SWSTART).

3. In the polling method, the program continuously waits for the EOC (End of Conversion) flag, reads the ADC value, and turns the LED ON/OFF based on a threshold.

4. In the interrupt method, ADC EOC interrupt is enabled, and the LED is controlled inside ADC_IRQHandler() based on the ADC conversion result stored in a global variable.

5. Both methods compare the ADC reading with a defined threshold (2000) to decide LED state, but differ in how the ADC conversion is monitored (polling loop vs interrupt service routine).

#include "stm32f4xx.h"

#define THRESHOLD 2000

volatile uint16_t adc_value = 0;

void delay(volatile uint32_t count) {
    while(count--) {
        __NOP();
    }
}

void ADC_IRQHandler(void) {
    if (ADC1->SR & ADC_SR_EOC) {
        adc_value = ADC1->DR;

        if (adc_value > THRESHOLD) {
            GPIOA->BSRR = (1U << 5);
        } else {
            GPIOA->BSRR = (1U << (5 + 16));
        }
    }
}

int main(void) {
    RCC->AHB1ENR |= (1U << 0);
    RCC->APB2ENR |= (1U << 8);

    GPIOA->MODER &= ~(0x3U << (5 * 2));
    GPIOA->MODER |=  (0x1U << (5 * 2));
    GPIOA->OTYPER &= ~(1U << 5);
    GPIOA->OSPEEDR &= ~(0x3U << (5 * 2));
    GPIOA->PUPDR &= ~(0x3U << (5 * 2));

    GPIOA->MODER &= ~(0x3U << 0);
    GPIOA->MODER |=  (0x3U << 0);

    ADC1->SQR3 &= ~0x1FU;
    ADC1->SQR3 |= 0;
    ADC1->SMPR2 &= ~(0x7U);
    ADC1->SMPR2 |=  (0x3U);
    ADC1->CR1 |= ADC_CR1_EOCIE;
    ADC1->CR2 |= ADC_CR2_ADON;

    NVIC_EnableIRQ(ADC_IRQn);

    ADC1->CR2 |= ADC_CR2_SWSTART;

    while(1) {
        delay(100000);
        ADC1->CR2 |= ADC_CR2_SWSTART;
    }
}
